"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sqlite";
exports.ids = ["vendor-chunks/sqlite"];
exports.modules = {

/***/ "(rsc)/./node_modules/sqlite/build/Database.js":
/*!***********************************************!*\
  !*** ./node_modules/sqlite/build/Database.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Database = void 0;\nconst Statement_1 = __webpack_require__(/*! ./Statement */ \"(rsc)/./node_modules/sqlite/build/Statement.js\");\nconst migrate_1 = __webpack_require__(/*! ./utils/migrate */ \"(rsc)/./node_modules/sqlite/build/utils/migrate.js\");\nconst strings_1 = __webpack_require__(/*! ./utils/strings */ \"(rsc)/./node_modules/sqlite/build/utils/strings.js\");\nconst format_error_1 = __webpack_require__(/*! ./utils/format-error */ \"(rsc)/./node_modules/sqlite/build/utils/format-error.js\");\n/**\n * Promisified wrapper for the sqlite3#Database interface.\n */\nclass Database {\n    constructor(config) {\n        this.config = config;\n        this.db = null;\n    }\n    /**\n     * Event handler when verbose mode is enabled.\n     * @see https://github.com/mapbox/node-sqlite3/wiki/Debugging\n     */\n    on(event, listener) {\n        this.db.on(event, listener);\n    }\n    /**\n     * Returns the underlying sqlite3 Database instance\n     */\n    getDatabaseInstance() {\n        return this.db;\n    }\n    /**\n     * Opens the database\n     */\n    open() {\n        return new Promise((resolve, reject) => {\n            let { filename, mode, driver } = this.config;\n            // https://github.com/mapbox/node-sqlite3/wiki/API#new-sqlite3databasefilename-mode-callback\n            if (filename === null || filename === undefined) {\n                throw new Error('sqlite: filename cannot be null / undefined');\n            }\n            if (!driver) {\n                throw new Error('sqlite: driver is not defined');\n            }\n            if (mode) {\n                this.db = new driver(filename, mode, err => {\n                    if (err) {\n                        return reject((0, format_error_1.formatError)(err));\n                    }\n                    resolve();\n                });\n            }\n            else {\n                this.db = new driver(filename, err => {\n                    if (err) {\n                        return reject((0, format_error_1.formatError)(err));\n                    }\n                    resolve();\n                });\n            }\n        });\n    }\n    /**\n     * Closes the database.\n     */\n    close() {\n        return new Promise((resolve, reject) => {\n            this.db.close(err => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve();\n            });\n        });\n    }\n    /**\n     * @see https://github.com/mapbox/node-sqlite3/wiki/API#databaseconfigureoption-value\n     */\n    configure(option, value) {\n        this.db.configure(option, value);\n    }\n    /**\n     * Runs the SQL query with the specified parameters. It does not retrieve any result data.\n     * The function returns the Database object for which it was called to allow for function chaining.\n     *\n     * @param {string} sql The SQL query to run.\n     *\n     * @param {any} [params, ...] When the SQL statement contains placeholders, you\n     * can pass them in here. They will be bound to the statement before it is\n     * executed. There are three ways of passing bind parameters: directly in\n     * the function's arguments, as an array, and as an object for named\n     * parameters. This automatically sanitizes inputs.\n     *\n     * @see https://github.com/mapbox/node-sqlite3/wiki/API#databaserunsql-param--callback\n     */\n    run(sql, ...params) {\n        return new Promise((resolve, reject) => {\n            const sqlObj = (0, strings_1.toSqlParams)(sql, params);\n            this.db.run(sqlObj.sql, ...sqlObj.params, function (err) {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve({\n                    stmt: new Statement_1.Statement(this.stmt),\n                    lastID: this.lastID,\n                    changes: this.changes\n                });\n            });\n        });\n    }\n    /**\n     * Runs the SQL query with the specified parameters and resolves with\n     * with the first result row afterwards. If the result set is empty, returns undefined.\n     *\n     * The property names correspond to the column names of the result set.\n     * It is impossible to access them by column index; the only supported way is by column name.\n     *\n     * @param {string} sql The SQL query to run.\n     *\n     * @param {any} [params, ...] When the SQL statement contains placeholders, you\n     * can pass them in here. They will be bound to the statement before it is\n     * executed. There are three ways of passing bind parameters: directly in\n     * the function's arguments, as an array, and as an object for named\n     * parameters. This automatically sanitizes inputs.\n     *\n     * @see https://github.com/mapbox/node-sqlite3/wiki/API#databasegetsql-param--callback\n     */\n    get(sql, ...params) {\n        return new Promise((resolve, reject) => {\n            const sqlObj = (0, strings_1.toSqlParams)(sql, params);\n            this.db.get(sqlObj.sql, ...sqlObj.params, (err, row) => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve(row);\n            });\n        });\n    }\n    each(sql, ...params) {\n        return new Promise((resolve, reject) => {\n            const callback = params.pop();\n            if (!callback || typeof callback !== 'function') {\n                throw new Error('sqlite: Last param of Database#each() must be a callback function');\n            }\n            if (params.length > 0) {\n                const positional = params.pop();\n                if (typeof positional === 'function') {\n                    throw new Error('sqlite: Database#each() should only have a single callback defined. See readme for usage.');\n                }\n                params.push(positional);\n            }\n            const sqlObj = (0, strings_1.toSqlParams)(sql, params);\n            this.db.each(sqlObj.sql, ...sqlObj.params, (err, row) => {\n                if (err) {\n                    return callback((0, format_error_1.formatError)(err), null);\n                }\n                callback(null, row);\n            }, (err, count) => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve(count);\n            });\n        });\n    }\n    /**\n     * Runs the SQL query with the specified parameters. The parameters are the same as the\n     * Database#run function, with the following differences:\n     *\n     * If the result set is empty, it will be an empty array, otherwise it will\n     * have an object for each result row which\n     * in turn contains the values of that row, like the Database#get function.\n     *\n     * Note that it first retrieves all result rows and stores them in memory.\n     * For queries that have potentially large result sets, use the Database#each\n     * function to retrieve all rows or Database#prepare followed by multiple\n     * Statement#get calls to retrieve a previously unknown amount of rows.\n     *\n     * @param {string} sql The SQL query to run.\n     *\n     * @param {any} [params, ...] When the SQL statement contains placeholders, you\n     * can pass them in here. They will be bound to the statement before it is\n     * executed. There are three ways of passing bind parameters: directly in\n     * the function's arguments, as an array, and as an object for named\n     * parameters. This automatically sanitizes inputs.\n     *\n     * @see https://github.com/mapbox/node-sqlite3/wiki/API#databaseallsql-param--callback\n     */\n    all(sql, ...params) {\n        return new Promise((resolve, reject) => {\n            const sqlObj = (0, strings_1.toSqlParams)(sql, params);\n            this.db.all(sqlObj.sql, ...sqlObj.params, (err, rows) => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve(rows);\n            });\n        });\n    }\n    /**\n     * Runs all SQL queries in the supplied string. No result rows are retrieved. If a query fails,\n     * no subsequent statements will be executed (wrap it in a transaction if you want all\n     * or none to be executed).\n     *\n     * Note: This function will only execute statements up to the first NULL byte.\n     * Comments are not allowed and will lead to runtime errors.\n     *\n     * @param {string} sql The SQL query to run.\n     * @see https://github.com/mapbox/node-sqlite3/wiki/API#databaseexecsql-callback\n     */\n    exec(sql) {\n        return new Promise((resolve, reject) => {\n            const sqlObj = (0, strings_1.toSqlParams)(sql);\n            this.db.exec(sqlObj.sql, err => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve();\n            });\n        });\n    }\n    /**\n     * Prepares the SQL statement and optionally binds the specified parameters.\n     * When bind parameters are supplied, they are bound to the prepared statement.\n     *\n     * @param {string} sql The SQL query to run.\n     * @param {any} [params, ...] When the SQL statement contains placeholders, you\n     * can pass them in here. They will be bound to the statement before it is\n     * executed. There are three ways of passing bind parameters: directly in\n     * the function's arguments, as an array, and as an object for named\n     * parameters. This automatically sanitizes inputs.\n     * @returns Promise<Statement> Statement object\n     */\n    prepare(sql, ...params) {\n        return new Promise((resolve, reject) => {\n            const sqlObj = (0, strings_1.toSqlParams)(sql, params);\n            const stmt = this.db.prepare(sqlObj.sql, ...sqlObj.params, err => {\n                if (err) {\n                    return reject(err);\n                }\n                resolve(new Statement_1.Statement(stmt));\n            });\n        });\n    }\n    /**\n     * Loads a compiled SQLite extension into the database connection object.\n     *\n     * @param {string} path Filename of the extension to load\n     */\n    loadExtension(path) {\n        return new Promise((resolve, reject) => {\n            this.db.loadExtension(path, err => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve();\n            });\n        });\n    }\n    /**\n     * Performs a database migration.\n     */\n    async migrate(config) {\n        await (0, migrate_1.migrate)(this, config);\n    }\n    /**\n     * The methods underneath requires creative work to implement. PRs / proposals accepted!\n     */\n    /*\n     * Unsure if serialize can be made into a promise.\n     */\n    serialize() {\n        throw new Error('sqlite: Currently not implemented. Use getDatabaseInstance().serialize() instead.');\n    }\n    /*\n     * Unsure if parallelize can be made into a promise.\n     */\n    parallelize() {\n        throw new Error('sqlite: Currently not implemented. Use getDatabaseInstance().parallelize() instead.');\n    }\n}\nexports.Database = Database;\n//# sourceMappingURL=Database.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3FsaXRlL2J1aWxkL0RhdGFiYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixvQkFBb0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQywyRUFBaUI7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsMkVBQWlCO0FBQzNDLHVCQUF1QixtQkFBTyxDQUFDLHFGQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldmFubi9Eb2N1bWVudHMvR2l0SHViL1NTTE9KX0dhbWUvbm9kZV9tb2R1bGVzL3NxbGl0ZS9idWlsZC9EYXRhYmFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGF0YWJhc2UgPSB2b2lkIDA7XG5jb25zdCBTdGF0ZW1lbnRfMSA9IHJlcXVpcmUoXCIuL1N0YXRlbWVudFwiKTtcbmNvbnN0IG1pZ3JhdGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL21pZ3JhdGVcIik7XG5jb25zdCBzdHJpbmdzXzEgPSByZXF1aXJlKFwiLi91dGlscy9zdHJpbmdzXCIpO1xuY29uc3QgZm9ybWF0X2Vycm9yXzEgPSByZXF1aXJlKFwiLi91dGlscy9mb3JtYXQtZXJyb3JcIik7XG4vKipcbiAqIFByb21pc2lmaWVkIHdyYXBwZXIgZm9yIHRoZSBzcWxpdGUzI0RhdGFiYXNlIGludGVyZmFjZS5cbiAqL1xuY2xhc3MgRGF0YWJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5kYiA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2ZW50IGhhbmRsZXIgd2hlbiB2ZXJib3NlIG1vZGUgaXMgZW5hYmxlZC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbm9kZS1zcWxpdGUzL3dpa2kvRGVidWdnaW5nXG4gICAgICovXG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZGIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBzcWxpdGUzIERhdGFiYXNlIGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0RGF0YWJhc2VJbnN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBkYXRhYmFzZVxuICAgICAqL1xuICAgIG9wZW4oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBmaWxlbmFtZSwgbW9kZSwgZHJpdmVyIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbm9kZS1zcWxpdGUzL3dpa2kvQVBJI25ldy1zcWxpdGUzZGF0YWJhc2VmaWxlbmFtZS1tb2RlLWNhbGxiYWNrXG4gICAgICAgICAgICBpZiAoZmlsZW5hbWUgPT09IG51bGwgfHwgZmlsZW5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3FsaXRlOiBmaWxlbmFtZSBjYW5ub3QgYmUgbnVsbCAvIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkcml2ZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxbGl0ZTogZHJpdmVyIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGIgPSBuZXcgZHJpdmVyKGZpbGVuYW1lLCBtb2RlLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KCgwLCBmb3JtYXRfZXJyb3JfMS5mb3JtYXRFcnJvcikoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYiA9IG5ldyBkcml2ZXIoZmlsZW5hbWUsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoKDAsIGZvcm1hdF9lcnJvcl8xLmZvcm1hdEVycm9yKShlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGRhdGFiYXNlLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kYi5jbG9zZShlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgoMCwgZm9ybWF0X2Vycm9yXzEuZm9ybWF0RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9ub2RlLXNxbGl0ZTMvd2lraS9BUEkjZGF0YWJhc2Vjb25maWd1cmVvcHRpb24tdmFsdWVcbiAgICAgKi9cbiAgICBjb25maWd1cmUob3B0aW9uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRiLmNvbmZpZ3VyZShvcHRpb24sIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgU1FMIHF1ZXJ5IHdpdGggdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLiBJdCBkb2VzIG5vdCByZXRyaWV2ZSBhbnkgcmVzdWx0IGRhdGEuXG4gICAgICogVGhlIGZ1bmN0aW9uIHJldHVybnMgdGhlIERhdGFiYXNlIG9iamVjdCBmb3Igd2hpY2ggaXQgd2FzIGNhbGxlZCB0byBhbGxvdyBmb3IgZnVuY3Rpb24gY2hhaW5pbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3FsIFRoZSBTUUwgcXVlcnkgdG8gcnVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IFtwYXJhbXMsIC4uLl0gV2hlbiB0aGUgU1FMIHN0YXRlbWVudCBjb250YWlucyBwbGFjZWhvbGRlcnMsIHlvdVxuICAgICAqIGNhbiBwYXNzIHRoZW0gaW4gaGVyZS4gVGhleSB3aWxsIGJlIGJvdW5kIHRvIHRoZSBzdGF0ZW1lbnQgYmVmb3JlIGl0IGlzXG4gICAgICogZXhlY3V0ZWQuIFRoZXJlIGFyZSB0aHJlZSB3YXlzIG9mIHBhc3NpbmcgYmluZCBwYXJhbWV0ZXJzOiBkaXJlY3RseSBpblxuICAgICAqIHRoZSBmdW5jdGlvbidzIGFyZ3VtZW50cywgYXMgYW4gYXJyYXksIGFuZCBhcyBhbiBvYmplY3QgZm9yIG5hbWVkXG4gICAgICogcGFyYW1ldGVycy4gVGhpcyBhdXRvbWF0aWNhbGx5IHNhbml0aXplcyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbm9kZS1zcWxpdGUzL3dpa2kvQVBJI2RhdGFiYXNlcnVuc3FsLXBhcmFtLS1jYWxsYmFja1xuICAgICAqL1xuICAgIHJ1bihzcWwsIC4uLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3FsT2JqID0gKDAsIHN0cmluZ3NfMS50b1NxbFBhcmFtcykoc3FsLCBwYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5kYi5ydW4oc3FsT2JqLnNxbCwgLi4uc3FsT2JqLnBhcmFtcywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgoMCwgZm9ybWF0X2Vycm9yXzEuZm9ybWF0RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgc3RtdDogbmV3IFN0YXRlbWVudF8xLlN0YXRlbWVudCh0aGlzLnN0bXQpLFxuICAgICAgICAgICAgICAgICAgICBsYXN0SUQ6IHRoaXMubGFzdElELFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiB0aGlzLmNoYW5nZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgU1FMIHF1ZXJ5IHdpdGggdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzIGFuZCByZXNvbHZlcyB3aXRoXG4gICAgICogd2l0aCB0aGUgZmlyc3QgcmVzdWx0IHJvdyBhZnRlcndhcmRzLiBJZiB0aGUgcmVzdWx0IHNldCBpcyBlbXB0eSwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBUaGUgcHJvcGVydHkgbmFtZXMgY29ycmVzcG9uZCB0byB0aGUgY29sdW1uIG5hbWVzIG9mIHRoZSByZXN1bHQgc2V0LlxuICAgICAqIEl0IGlzIGltcG9zc2libGUgdG8gYWNjZXNzIHRoZW0gYnkgY29sdW1uIGluZGV4OyB0aGUgb25seSBzdXBwb3J0ZWQgd2F5IGlzIGJ5IGNvbHVtbiBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNxbCBUaGUgU1FMIHF1ZXJ5IHRvIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSBbcGFyYW1zLCAuLi5dIFdoZW4gdGhlIFNRTCBzdGF0ZW1lbnQgY29udGFpbnMgcGxhY2Vob2xkZXJzLCB5b3VcbiAgICAgKiBjYW4gcGFzcyB0aGVtIGluIGhlcmUuIFRoZXkgd2lsbCBiZSBib3VuZCB0byB0aGUgc3RhdGVtZW50IGJlZm9yZSBpdCBpc1xuICAgICAqIGV4ZWN1dGVkLiBUaGVyZSBhcmUgdGhyZWUgd2F5cyBvZiBwYXNzaW5nIGJpbmQgcGFyYW1ldGVyczogZGlyZWN0bHkgaW5cbiAgICAgKiB0aGUgZnVuY3Rpb24ncyBhcmd1bWVudHMsIGFzIGFuIGFycmF5LCBhbmQgYXMgYW4gb2JqZWN0IGZvciBuYW1lZFxuICAgICAqIHBhcmFtZXRlcnMuIFRoaXMgYXV0b21hdGljYWxseSBzYW5pdGl6ZXMgaW5wdXRzLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L25vZGUtc3FsaXRlMy93aWtpL0FQSSNkYXRhYmFzZWdldHNxbC1wYXJhbS0tY2FsbGJhY2tcbiAgICAgKi9cbiAgICBnZXQoc3FsLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNxbE9iaiA9ICgwLCBzdHJpbmdzXzEudG9TcWxQYXJhbXMpKHNxbCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMuZGIuZ2V0KHNxbE9iai5zcWwsIC4uLnNxbE9iai5wYXJhbXMsIChlcnIsIHJvdykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgoMCwgZm9ybWF0X2Vycm9yXzEuZm9ybWF0RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJvdyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVhY2goc3FsLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gcGFyYW1zLnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxbGl0ZTogTGFzdCBwYXJhbSBvZiBEYXRhYmFzZSNlYWNoKCkgbXVzdCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbmFsID0gcGFyYW1zLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb25hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxbGl0ZTogRGF0YWJhc2UjZWFjaCgpIHNob3VsZCBvbmx5IGhhdmUgYSBzaW5nbGUgY2FsbGJhY2sgZGVmaW5lZC4gU2VlIHJlYWRtZSBmb3IgdXNhZ2UuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBvc2l0aW9uYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3FsT2JqID0gKDAsIHN0cmluZ3NfMS50b1NxbFBhcmFtcykoc3FsLCBwYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5kYi5lYWNoKHNxbE9iai5zcWwsIC4uLnNxbE9iai5wYXJhbXMsIChlcnIsIHJvdykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCgwLCBmb3JtYXRfZXJyb3JfMS5mb3JtYXRFcnJvcikoZXJyKSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJvdyk7XG4gICAgICAgICAgICB9LCAoZXJyLCBjb3VudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgoMCwgZm9ybWF0X2Vycm9yXzEuZm9ybWF0RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKGNvdW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgU1FMIHF1ZXJ5IHdpdGggdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLiBUaGUgcGFyYW1ldGVycyBhcmUgdGhlIHNhbWUgYXMgdGhlXG4gICAgICogRGF0YWJhc2UjcnVuIGZ1bmN0aW9uLCB3aXRoIHRoZSBmb2xsb3dpbmcgZGlmZmVyZW5jZXM6XG4gICAgICpcbiAgICAgKiBJZiB0aGUgcmVzdWx0IHNldCBpcyBlbXB0eSwgaXQgd2lsbCBiZSBhbiBlbXB0eSBhcnJheSwgb3RoZXJ3aXNlIGl0IHdpbGxcbiAgICAgKiBoYXZlIGFuIG9iamVjdCBmb3IgZWFjaCByZXN1bHQgcm93IHdoaWNoXG4gICAgICogaW4gdHVybiBjb250YWlucyB0aGUgdmFsdWVzIG9mIHRoYXQgcm93LCBsaWtlIHRoZSBEYXRhYmFzZSNnZXQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgaXQgZmlyc3QgcmV0cmlldmVzIGFsbCByZXN1bHQgcm93cyBhbmQgc3RvcmVzIHRoZW0gaW4gbWVtb3J5LlxuICAgICAqIEZvciBxdWVyaWVzIHRoYXQgaGF2ZSBwb3RlbnRpYWxseSBsYXJnZSByZXN1bHQgc2V0cywgdXNlIHRoZSBEYXRhYmFzZSNlYWNoXG4gICAgICogZnVuY3Rpb24gdG8gcmV0cmlldmUgYWxsIHJvd3Mgb3IgRGF0YWJhc2UjcHJlcGFyZSBmb2xsb3dlZCBieSBtdWx0aXBsZVxuICAgICAqIFN0YXRlbWVudCNnZXQgY2FsbHMgdG8gcmV0cmlldmUgYSBwcmV2aW91c2x5IHVua25vd24gYW1vdW50IG9mIHJvd3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3FsIFRoZSBTUUwgcXVlcnkgdG8gcnVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IFtwYXJhbXMsIC4uLl0gV2hlbiB0aGUgU1FMIHN0YXRlbWVudCBjb250YWlucyBwbGFjZWhvbGRlcnMsIHlvdVxuICAgICAqIGNhbiBwYXNzIHRoZW0gaW4gaGVyZS4gVGhleSB3aWxsIGJlIGJvdW5kIHRvIHRoZSBzdGF0ZW1lbnQgYmVmb3JlIGl0IGlzXG4gICAgICogZXhlY3V0ZWQuIFRoZXJlIGFyZSB0aHJlZSB3YXlzIG9mIHBhc3NpbmcgYmluZCBwYXJhbWV0ZXJzOiBkaXJlY3RseSBpblxuICAgICAqIHRoZSBmdW5jdGlvbidzIGFyZ3VtZW50cywgYXMgYW4gYXJyYXksIGFuZCBhcyBhbiBvYmplY3QgZm9yIG5hbWVkXG4gICAgICogcGFyYW1ldGVycy4gVGhpcyBhdXRvbWF0aWNhbGx5IHNhbml0aXplcyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbm9kZS1zcWxpdGUzL3dpa2kvQVBJI2RhdGFiYXNlYWxsc3FsLXBhcmFtLS1jYWxsYmFja1xuICAgICAqL1xuICAgIGFsbChzcWwsIC4uLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3FsT2JqID0gKDAsIHN0cmluZ3NfMS50b1NxbFBhcmFtcykoc3FsLCBwYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5kYi5hbGwoc3FsT2JqLnNxbCwgLi4uc3FsT2JqLnBhcmFtcywgKGVyciwgcm93cykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgoMCwgZm9ybWF0X2Vycm9yXzEuZm9ybWF0RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJvd3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIGFsbCBTUUwgcXVlcmllcyBpbiB0aGUgc3VwcGxpZWQgc3RyaW5nLiBObyByZXN1bHQgcm93cyBhcmUgcmV0cmlldmVkLiBJZiBhIHF1ZXJ5IGZhaWxzLFxuICAgICAqIG5vIHN1YnNlcXVlbnQgc3RhdGVtZW50cyB3aWxsIGJlIGV4ZWN1dGVkICh3cmFwIGl0IGluIGEgdHJhbnNhY3Rpb24gaWYgeW91IHdhbnQgYWxsXG4gICAgICogb3Igbm9uZSB0byBiZSBleGVjdXRlZCkuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIHdpbGwgb25seSBleGVjdXRlIHN0YXRlbWVudHMgdXAgdG8gdGhlIGZpcnN0IE5VTEwgYnl0ZS5cbiAgICAgKiBDb21tZW50cyBhcmUgbm90IGFsbG93ZWQgYW5kIHdpbGwgbGVhZCB0byBydW50aW1lIGVycm9ycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzcWwgVGhlIFNRTCBxdWVyeSB0byBydW4uXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L25vZGUtc3FsaXRlMy93aWtpL0FQSSNkYXRhYmFzZWV4ZWNzcWwtY2FsbGJhY2tcbiAgICAgKi9cbiAgICBleGVjKHNxbCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3FsT2JqID0gKDAsIHN0cmluZ3NfMS50b1NxbFBhcmFtcykoc3FsKTtcbiAgICAgICAgICAgIHRoaXMuZGIuZXhlYyhzcWxPYmouc3FsLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgoMCwgZm9ybWF0X2Vycm9yXzEuZm9ybWF0RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIHRoZSBTUUwgc3RhdGVtZW50IGFuZCBvcHRpb25hbGx5IGJpbmRzIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy5cbiAgICAgKiBXaGVuIGJpbmQgcGFyYW1ldGVycyBhcmUgc3VwcGxpZWQsIHRoZXkgYXJlIGJvdW5kIHRvIHRoZSBwcmVwYXJlZCBzdGF0ZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3FsIFRoZSBTUUwgcXVlcnkgdG8gcnVuLlxuICAgICAqIEBwYXJhbSB7YW55fSBbcGFyYW1zLCAuLi5dIFdoZW4gdGhlIFNRTCBzdGF0ZW1lbnQgY29udGFpbnMgcGxhY2Vob2xkZXJzLCB5b3VcbiAgICAgKiBjYW4gcGFzcyB0aGVtIGluIGhlcmUuIFRoZXkgd2lsbCBiZSBib3VuZCB0byB0aGUgc3RhdGVtZW50IGJlZm9yZSBpdCBpc1xuICAgICAqIGV4ZWN1dGVkLiBUaGVyZSBhcmUgdGhyZWUgd2F5cyBvZiBwYXNzaW5nIGJpbmQgcGFyYW1ldGVyczogZGlyZWN0bHkgaW5cbiAgICAgKiB0aGUgZnVuY3Rpb24ncyBhcmd1bWVudHMsIGFzIGFuIGFycmF5LCBhbmQgYXMgYW4gb2JqZWN0IGZvciBuYW1lZFxuICAgICAqIHBhcmFtZXRlcnMuIFRoaXMgYXV0b21hdGljYWxseSBzYW5pdGl6ZXMgaW5wdXRzLlxuICAgICAqIEByZXR1cm5zIFByb21pc2U8U3RhdGVtZW50PiBTdGF0ZW1lbnQgb2JqZWN0XG4gICAgICovXG4gICAgcHJlcGFyZShzcWwsIC4uLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3FsT2JqID0gKDAsIHN0cmluZ3NfMS50b1NxbFBhcmFtcykoc3FsLCBwYXJhbXMpO1xuICAgICAgICAgICAgY29uc3Qgc3RtdCA9IHRoaXMuZGIucHJlcGFyZShzcWxPYmouc3FsLCAuLi5zcWxPYmoucGFyYW1zLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBTdGF0ZW1lbnRfMS5TdGF0ZW1lbnQoc3RtdCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIGNvbXBpbGVkIFNRTGl0ZSBleHRlbnNpb24gaW50byB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBGaWxlbmFtZSBvZiB0aGUgZXh0ZW5zaW9uIHRvIGxvYWRcbiAgICAgKi9cbiAgICBsb2FkRXh0ZW5zaW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGIubG9hZEV4dGVuc2lvbihwYXRoLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgoMCwgZm9ybWF0X2Vycm9yXzEuZm9ybWF0RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGF0YWJhc2UgbWlncmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIG1pZ3JhdGUoY29uZmlnKSB7XG4gICAgICAgIGF3YWl0ICgwLCBtaWdyYXRlXzEubWlncmF0ZSkodGhpcywgY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZHMgdW5kZXJuZWF0aCByZXF1aXJlcyBjcmVhdGl2ZSB3b3JrIHRvIGltcGxlbWVudC4gUFJzIC8gcHJvcG9zYWxzIGFjY2VwdGVkIVxuICAgICAqL1xuICAgIC8qXG4gICAgICogVW5zdXJlIGlmIHNlcmlhbGl6ZSBjYW4gYmUgbWFkZSBpbnRvIGEgcHJvbWlzZS5cbiAgICAgKi9cbiAgICBzZXJpYWxpemUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3FsaXRlOiBDdXJyZW50bHkgbm90IGltcGxlbWVudGVkLiBVc2UgZ2V0RGF0YWJhc2VJbnN0YW5jZSgpLnNlcmlhbGl6ZSgpIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIC8qXG4gICAgICogVW5zdXJlIGlmIHBhcmFsbGVsaXplIGNhbiBiZSBtYWRlIGludG8gYSBwcm9taXNlLlxuICAgICAqL1xuICAgIHBhcmFsbGVsaXplKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxbGl0ZTogQ3VycmVudGx5IG5vdCBpbXBsZW1lbnRlZC4gVXNlIGdldERhdGFiYXNlSW5zdGFuY2UoKS5wYXJhbGxlbGl6ZSgpIGluc3RlYWQuJyk7XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhYmFzZSA9IERhdGFiYXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0YWJhc2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sqlite/build/Database.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sqlite/build/Statement.js":
/*!************************************************!*\
  !*** ./node_modules/sqlite/build/Statement.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Statement = void 0;\nconst format_error_1 = __webpack_require__(/*! ./utils/format-error */ \"(rsc)/./node_modules/sqlite/build/utils/format-error.js\");\n/**\n * Promisified wrapper for the sqlite3#Statement interface.\n */\nclass Statement {\n    constructor(stmt) {\n        this.stmt = stmt;\n    }\n    /**\n     * Returns the underlying sqlite3 Statement instance\n     */\n    getStatementInstance() {\n        return this.stmt;\n    }\n    /**\n     * Binds parameters to the prepared statement.\n     *\n     * Binding parameters with this function completely resets the statement object and row cursor\n     * and removes all previously bound parameters, if any.\n     */\n    bind(...params) {\n        return new Promise((resolve, reject) => {\n            this.stmt.bind(...params, err => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve();\n            });\n        });\n    }\n    /**\n     * Resets the row cursor of the statement and preserves the parameter bindings.\n     * Use this function to re-execute the same query with the same bindings.\n     */\n    reset() {\n        return new Promise(resolve => {\n            this.stmt.reset(() => {\n                resolve();\n            });\n        });\n    }\n    /**\n     * Finalizes the statement. This is typically optional, but if you experience long delays before\n     * the next query is executed, explicitly finalizing your statement might be necessary.\n     * This might be the case when you run an exclusive query (see section Control Flow).\n     * After the statement is finalized, all further function calls on that statement object\n     * will throw errors.\n     */\n    finalize() {\n        return new Promise((resolve, reject) => {\n            this.stmt.finalize(err => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve();\n            });\n        });\n    }\n    /**\n     * Binds parameters and executes the statement.\n     *\n     * If you specify bind parameters, they will be bound to the statement before it is executed.\n     * Note that the bindings and the row cursor are reset when you specify even a single bind parameter.\n     *\n     * The execution behavior is identical to the Database#run method with the difference that the\n     * statement will not be finalized after it is run. This means you can run it multiple times.\n     *\n     * @param {any} [params, ...] When the SQL statement contains placeholders, you\n     * can pass them in here. They will be bound to the statement before it is\n     * executed. There are three ways of passing bind parameters: directly in\n     * the function's arguments, as an array, and as an object for named\n     * parameters. This automatically sanitizes inputs.\n     */\n    run(...params) {\n        return new Promise((resolve, reject) => {\n            const stmt = this;\n            this.stmt.run(...params, function (err) {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve({\n                    stmt,\n                    lastID: this.lastID,\n                    changes: this.changes\n                });\n            });\n        });\n    }\n    /**\n     * Binds parameters, executes the statement and retrieves the first result row.\n     * The parameters are the same as the Statement#run function, with the following differences:\n     *\n     * Using this method can leave the database locked, as the database awaits further\n     * calls to Statement#get to retrieve subsequent rows. To inform the database that you\n     * are finished retrieving rows, you should either finalize (with Statement#finalize)\n     * or reset (with Statement#reset) the statement.\n     *\n     * @param {any} [params, ...] When the SQL statement contains placeholders, you\n     * can pass them in here. They will be bound to the statement before it is\n     * executed. There are three ways of passing bind parameters: directly in\n     * the function's arguments, as an array, and as an object for named\n     * parameters. This automatically sanitizes inputs.\n     */\n    get(...params) {\n        return new Promise((resolve, reject) => {\n            this.stmt.get(...params, (err, row) => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve(row);\n            });\n        });\n    }\n    /**\n     * Binds parameters, executes the statement and calls the callback with all result rows.\n     * The parameters are the same as the Statement#run function, with the following differences:\n     *\n     * If the result set is empty, it will resolve to an empty array, otherwise it contains an\n     * object for each result row which in turn contains the values of that row.\n     * Like with Statement#run, the statement will not be finalized after executing this function.\n     *\n     * @param {any} [params, ...] When the SQL statement contains placeholders, you\n     * can pass them in here. They will be bound to the statement before it is\n     * executed. There are three ways of passing bind parameters: directly in\n     * the function's arguments, as an array, and as an object for named\n     * parameters. This automatically sanitizes inputs.\n     *\n     * @see https://github.com/mapbox/node-sqlite3/wiki/API#databaseallsql-param--callback\n     */\n    all(...params) {\n        return new Promise((resolve, reject) => {\n            this.stmt.all(...params, (err, rows) => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve(rows);\n            });\n        });\n    }\n    each(...params) {\n        return new Promise((resolve, reject) => {\n            const callback = params.pop();\n            if (!callback || typeof callback !== 'function') {\n                throw new Error('sqlite: Last param of Statement#each() must be a callback function');\n            }\n            if (params.length > 0) {\n                const positional = params.pop();\n                if (typeof positional === 'function') {\n                    throw new Error('sqlite: Statement#each() should only have a single callback defined. See readme for usage.');\n                }\n                params.push(positional);\n            }\n            this.stmt.each(...params, (err, row) => {\n                if (err) {\n                    return callback((0, format_error_1.formatError)(err), null);\n                }\n                callback(null, row);\n            }, (err, count) => {\n                if (err) {\n                    return reject((0, format_error_1.formatError)(err));\n                }\n                resolve(count);\n            });\n        });\n    }\n}\nexports.Statement = Statement;\n//# sourceMappingURL=Statement.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3FsaXRlL2J1aWxkL1N0YXRlbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsdUJBQXVCLG1CQUFPLENBQUMscUZBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyIvVXNlcnMvZXZhbm4vRG9jdW1lbnRzL0dpdEh1Yi9TU0xPSl9HYW1lL25vZGVfbW9kdWxlcy9zcWxpdGUvYnVpbGQvU3RhdGVtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdGF0ZW1lbnQgPSB2b2lkIDA7XG5jb25zdCBmb3JtYXRfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdC1lcnJvclwiKTtcbi8qKlxuICogUHJvbWlzaWZpZWQgd3JhcHBlciBmb3IgdGhlIHNxbGl0ZTMjU3RhdGVtZW50IGludGVyZmFjZS5cbiAqL1xuY2xhc3MgU3RhdGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzdG10KSB7XG4gICAgICAgIHRoaXMuc3RtdCA9IHN0bXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgc3FsaXRlMyBTdGF0ZW1lbnQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXRTdGF0ZW1lbnRJbnN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RtdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZHMgcGFyYW1ldGVycyB0byB0aGUgcHJlcGFyZWQgc3RhdGVtZW50LlxuICAgICAqXG4gICAgICogQmluZGluZyBwYXJhbWV0ZXJzIHdpdGggdGhpcyBmdW5jdGlvbiBjb21wbGV0ZWx5IHJlc2V0cyB0aGUgc3RhdGVtZW50IG9iamVjdCBhbmQgcm93IGN1cnNvclxuICAgICAqIGFuZCByZW1vdmVzIGFsbCBwcmV2aW91c2x5IGJvdW5kIHBhcmFtZXRlcnMsIGlmIGFueS5cbiAgICAgKi9cbiAgICBiaW5kKC4uLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdG10LmJpbmQoLi4ucGFyYW1zLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgoMCwgZm9ybWF0X2Vycm9yXzEuZm9ybWF0RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgcm93IGN1cnNvciBvZiB0aGUgc3RhdGVtZW50IGFuZCBwcmVzZXJ2ZXMgdGhlIHBhcmFtZXRlciBiaW5kaW5ncy5cbiAgICAgKiBVc2UgdGhpcyBmdW5jdGlvbiB0byByZS1leGVjdXRlIHRoZSBzYW1lIHF1ZXJ5IHdpdGggdGhlIHNhbWUgYmluZGluZ3MuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RtdC5yZXNldCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5hbGl6ZXMgdGhlIHN0YXRlbWVudC4gVGhpcyBpcyB0eXBpY2FsbHkgb3B0aW9uYWwsIGJ1dCBpZiB5b3UgZXhwZXJpZW5jZSBsb25nIGRlbGF5cyBiZWZvcmVcbiAgICAgKiB0aGUgbmV4dCBxdWVyeSBpcyBleGVjdXRlZCwgZXhwbGljaXRseSBmaW5hbGl6aW5nIHlvdXIgc3RhdGVtZW50IG1pZ2h0IGJlIG5lY2Vzc2FyeS5cbiAgICAgKiBUaGlzIG1pZ2h0IGJlIHRoZSBjYXNlIHdoZW4geW91IHJ1biBhbiBleGNsdXNpdmUgcXVlcnkgKHNlZSBzZWN0aW9uIENvbnRyb2wgRmxvdykuXG4gICAgICogQWZ0ZXIgdGhlIHN0YXRlbWVudCBpcyBmaW5hbGl6ZWQsIGFsbCBmdXJ0aGVyIGZ1bmN0aW9uIGNhbGxzIG9uIHRoYXQgc3RhdGVtZW50IG9iamVjdFxuICAgICAqIHdpbGwgdGhyb3cgZXJyb3JzLlxuICAgICAqL1xuICAgIGZpbmFsaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdG10LmZpbmFsaXplKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KCgwLCBmb3JtYXRfZXJyb3JfMS5mb3JtYXRFcnJvcikoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZHMgcGFyYW1ldGVycyBhbmQgZXhlY3V0ZXMgdGhlIHN0YXRlbWVudC5cbiAgICAgKlxuICAgICAqIElmIHlvdSBzcGVjaWZ5IGJpbmQgcGFyYW1ldGVycywgdGhleSB3aWxsIGJlIGJvdW5kIHRvIHRoZSBzdGF0ZW1lbnQgYmVmb3JlIGl0IGlzIGV4ZWN1dGVkLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgYmluZGluZ3MgYW5kIHRoZSByb3cgY3Vyc29yIGFyZSByZXNldCB3aGVuIHlvdSBzcGVjaWZ5IGV2ZW4gYSBzaW5nbGUgYmluZCBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBUaGUgZXhlY3V0aW9uIGJlaGF2aW9yIGlzIGlkZW50aWNhbCB0byB0aGUgRGF0YWJhc2UjcnVuIG1ldGhvZCB3aXRoIHRoZSBkaWZmZXJlbmNlIHRoYXQgdGhlXG4gICAgICogc3RhdGVtZW50IHdpbGwgbm90IGJlIGZpbmFsaXplZCBhZnRlciBpdCBpcyBydW4uIFRoaXMgbWVhbnMgeW91IGNhbiBydW4gaXQgbXVsdGlwbGUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gW3BhcmFtcywgLi4uXSBXaGVuIHRoZSBTUUwgc3RhdGVtZW50IGNvbnRhaW5zIHBsYWNlaG9sZGVycywgeW91XG4gICAgICogY2FuIHBhc3MgdGhlbSBpbiBoZXJlLiBUaGV5IHdpbGwgYmUgYm91bmQgdG8gdGhlIHN0YXRlbWVudCBiZWZvcmUgaXQgaXNcbiAgICAgKiBleGVjdXRlZC4gVGhlcmUgYXJlIHRocmVlIHdheXMgb2YgcGFzc2luZyBiaW5kIHBhcmFtZXRlcnM6IGRpcmVjdGx5IGluXG4gICAgICogdGhlIGZ1bmN0aW9uJ3MgYXJndW1lbnRzLCBhcyBhbiBhcnJheSwgYW5kIGFzIGFuIG9iamVjdCBmb3IgbmFtZWRcbiAgICAgKiBwYXJhbWV0ZXJzLiBUaGlzIGF1dG9tYXRpY2FsbHkgc2FuaXRpemVzIGlucHV0cy5cbiAgICAgKi9cbiAgICBydW4oLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdG10ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuc3RtdC5ydW4oLi4ucGFyYW1zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KCgwLCBmb3JtYXRfZXJyb3JfMS5mb3JtYXRFcnJvcikoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICBzdG10LFxuICAgICAgICAgICAgICAgICAgICBsYXN0SUQ6IHRoaXMubGFzdElELFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiB0aGlzLmNoYW5nZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZHMgcGFyYW1ldGVycywgZXhlY3V0ZXMgdGhlIHN0YXRlbWVudCBhbmQgcmV0cmlldmVzIHRoZSBmaXJzdCByZXN1bHQgcm93LlxuICAgICAqIFRoZSBwYXJhbWV0ZXJzIGFyZSB0aGUgc2FtZSBhcyB0aGUgU3RhdGVtZW50I3J1biBmdW5jdGlvbiwgd2l0aCB0aGUgZm9sbG93aW5nIGRpZmZlcmVuY2VzOlxuICAgICAqXG4gICAgICogVXNpbmcgdGhpcyBtZXRob2QgY2FuIGxlYXZlIHRoZSBkYXRhYmFzZSBsb2NrZWQsIGFzIHRoZSBkYXRhYmFzZSBhd2FpdHMgZnVydGhlclxuICAgICAqIGNhbGxzIHRvIFN0YXRlbWVudCNnZXQgdG8gcmV0cmlldmUgc3Vic2VxdWVudCByb3dzLiBUbyBpbmZvcm0gdGhlIGRhdGFiYXNlIHRoYXQgeW91XG4gICAgICogYXJlIGZpbmlzaGVkIHJldHJpZXZpbmcgcm93cywgeW91IHNob3VsZCBlaXRoZXIgZmluYWxpemUgKHdpdGggU3RhdGVtZW50I2ZpbmFsaXplKVxuICAgICAqIG9yIHJlc2V0ICh3aXRoIFN0YXRlbWVudCNyZXNldCkgdGhlIHN0YXRlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSBbcGFyYW1zLCAuLi5dIFdoZW4gdGhlIFNRTCBzdGF0ZW1lbnQgY29udGFpbnMgcGxhY2Vob2xkZXJzLCB5b3VcbiAgICAgKiBjYW4gcGFzcyB0aGVtIGluIGhlcmUuIFRoZXkgd2lsbCBiZSBib3VuZCB0byB0aGUgc3RhdGVtZW50IGJlZm9yZSBpdCBpc1xuICAgICAqIGV4ZWN1dGVkLiBUaGVyZSBhcmUgdGhyZWUgd2F5cyBvZiBwYXNzaW5nIGJpbmQgcGFyYW1ldGVyczogZGlyZWN0bHkgaW5cbiAgICAgKiB0aGUgZnVuY3Rpb24ncyBhcmd1bWVudHMsIGFzIGFuIGFycmF5LCBhbmQgYXMgYW4gb2JqZWN0IGZvciBuYW1lZFxuICAgICAqIHBhcmFtZXRlcnMuIFRoaXMgYXV0b21hdGljYWxseSBzYW5pdGl6ZXMgaW5wdXRzLlxuICAgICAqL1xuICAgIGdldCguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RtdC5nZXQoLi4ucGFyYW1zLCAoZXJyLCByb3cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoKDAsIGZvcm1hdF9lcnJvcl8xLmZvcm1hdEVycm9yKShlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyb3cpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kcyBwYXJhbWV0ZXJzLCBleGVjdXRlcyB0aGUgc3RhdGVtZW50IGFuZCBjYWxscyB0aGUgY2FsbGJhY2sgd2l0aCBhbGwgcmVzdWx0IHJvd3MuXG4gICAgICogVGhlIHBhcmFtZXRlcnMgYXJlIHRoZSBzYW1lIGFzIHRoZSBTdGF0ZW1lbnQjcnVuIGZ1bmN0aW9uLCB3aXRoIHRoZSBmb2xsb3dpbmcgZGlmZmVyZW5jZXM6XG4gICAgICpcbiAgICAgKiBJZiB0aGUgcmVzdWx0IHNldCBpcyBlbXB0eSwgaXQgd2lsbCByZXNvbHZlIHRvIGFuIGVtcHR5IGFycmF5LCBvdGhlcndpc2UgaXQgY29udGFpbnMgYW5cbiAgICAgKiBvYmplY3QgZm9yIGVhY2ggcmVzdWx0IHJvdyB3aGljaCBpbiB0dXJuIGNvbnRhaW5zIHRoZSB2YWx1ZXMgb2YgdGhhdCByb3cuXG4gICAgICogTGlrZSB3aXRoIFN0YXRlbWVudCNydW4sIHRoZSBzdGF0ZW1lbnQgd2lsbCBub3QgYmUgZmluYWxpemVkIGFmdGVyIGV4ZWN1dGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IFtwYXJhbXMsIC4uLl0gV2hlbiB0aGUgU1FMIHN0YXRlbWVudCBjb250YWlucyBwbGFjZWhvbGRlcnMsIHlvdVxuICAgICAqIGNhbiBwYXNzIHRoZW0gaW4gaGVyZS4gVGhleSB3aWxsIGJlIGJvdW5kIHRvIHRoZSBzdGF0ZW1lbnQgYmVmb3JlIGl0IGlzXG4gICAgICogZXhlY3V0ZWQuIFRoZXJlIGFyZSB0aHJlZSB3YXlzIG9mIHBhc3NpbmcgYmluZCBwYXJhbWV0ZXJzOiBkaXJlY3RseSBpblxuICAgICAqIHRoZSBmdW5jdGlvbidzIGFyZ3VtZW50cywgYXMgYW4gYXJyYXksIGFuZCBhcyBhbiBvYmplY3QgZm9yIG5hbWVkXG4gICAgICogcGFyYW1ldGVycy4gVGhpcyBhdXRvbWF0aWNhbGx5IHNhbml0aXplcyBpbnB1dHMuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbm9kZS1zcWxpdGUzL3dpa2kvQVBJI2RhdGFiYXNlYWxsc3FsLXBhcmFtLS1jYWxsYmFja1xuICAgICAqL1xuICAgIGFsbCguLi5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RtdC5hbGwoLi4ucGFyYW1zLCAoZXJyLCByb3dzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KCgwLCBmb3JtYXRfZXJyb3JfMS5mb3JtYXRFcnJvcikoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocm93cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVhY2goLi4ucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHBhcmFtcy5wb3AoKTtcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcWxpdGU6IExhc3QgcGFyYW0gb2YgU3RhdGVtZW50I2VhY2goKSBtdXN0IGJlIGEgY2FsbGJhY2sgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uYWwgPSBwYXJhbXMucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3FsaXRlOiBTdGF0ZW1lbnQjZWFjaCgpIHNob3VsZCBvbmx5IGhhdmUgYSBzaW5nbGUgY2FsbGJhY2sgZGVmaW5lZC4gU2VlIHJlYWRtZSBmb3IgdXNhZ2UuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBvc2l0aW9uYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdG10LmVhY2goLi4ucGFyYW1zLCAoZXJyLCByb3cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygoMCwgZm9ybWF0X2Vycm9yXzEuZm9ybWF0RXJyb3IpKGVyciksIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByb3cpO1xuICAgICAgICAgICAgfSwgKGVyciwgY291bnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoKDAsIGZvcm1hdF9lcnJvcl8xLmZvcm1hdEVycm9yKShlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShjb3VudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdGF0ZW1lbnQgPSBTdGF0ZW1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0ZW1lbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sqlite/build/Statement.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sqlite/build/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/sqlite/build/index.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Database: () => (/* reexport safe */ _Database_js__WEBPACK_IMPORTED_MODULE_1__.Database),\n/* harmony export */   Statement: () => (/* reexport safe */ _Statement_js__WEBPACK_IMPORTED_MODULE_0__.Statement),\n/* harmony export */   __esModule: () => (/* reexport safe */ _Statement_js__WEBPACK_IMPORTED_MODULE_0__.__esModule),\n/* harmony export */   open: () => (/* binding */ open)\n/* harmony export */ });\n/* harmony import */ var _Statement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Statement.js */ \"(rsc)/./node_modules/sqlite/build/Statement.js\");\n/* harmony import */ var _Database_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Database.js */ \"(rsc)/./node_modules/sqlite/build/Database.js\");\n\n\n\n\n/**\n * Opens a database for manipulation. Most users will call this to get started.\n */\nasync function open(config) {\n  const db = new _Database_js__WEBPACK_IMPORTED_MODULE_1__.Database(config);\n  await db.open();\n  return db;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3FsaXRlL2J1aWxkL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0I7QUFDRDtBQUNPOztBQUVyQztBQUNBO0FBQ0E7QUFDTztBQUNQLGlCQUFpQixrREFBaUI7QUFDbEM7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvZXZhbm4vRG9jdW1lbnRzL0dpdEh1Yi9TU0xPSl9HYW1lL25vZGVfbW9kdWxlcy9zcWxpdGUvYnVpbGQvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL1N0YXRlbWVudC5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vRGF0YWJhc2UuanNcIjtcbmltcG9ydCBEYXRhYmFzZSBmcm9tIFwiLi9EYXRhYmFzZS5qc1wiO1xuXG4vKipcbiAqIE9wZW5zIGEgZGF0YWJhc2UgZm9yIG1hbmlwdWxhdGlvbi4gTW9zdCB1c2VycyB3aWxsIGNhbGwgdGhpcyB0byBnZXQgc3RhcnRlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG9wZW4oY29uZmlnKSB7XG4gIGNvbnN0IGRiID0gbmV3IERhdGFiYXNlLkRhdGFiYXNlKGNvbmZpZyk7XG4gIGF3YWl0IGRiLm9wZW4oKTtcbiAgcmV0dXJuIGRiO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sqlite/build/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/sqlite/build/utils/format-error.js":
/*!*********************************************************!*\
  !*** ./node_modules/sqlite/build/utils/format-error.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.formatError = void 0;\nfunction formatError(err) {\n    if (err instanceof Error) {\n        return err;\n    }\n    if (typeof err === 'object') {\n        const newError = new Error();\n        for (let prop in err) {\n            newError[prop] = err[prop];\n        }\n        // message isn't part of the enumerable set\n        if (err.message) {\n            newError.message = err.message;\n        }\n        return newError;\n    }\n    if (typeof err === 'string') {\n        return new Error(err);\n    }\n    return new Error(err);\n}\nexports.formatError = formatError;\n//# sourceMappingURL=format-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3FsaXRlL2J1aWxkL3V0aWxzL2Zvcm1hdC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsiL1VzZXJzL2V2YW5uL0RvY3VtZW50cy9HaXRIdWIvU1NMT0pfR2FtZS9ub2RlX21vZHVsZXMvc3FsaXRlL2J1aWxkL3V0aWxzL2Zvcm1hdC1lcnJvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZm9ybWF0RXJyb3IgPSB2b2lkIDA7XG5mdW5jdGlvbiBmb3JtYXRFcnJvcihlcnIpIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IG5ld0Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gZXJyKSB7XG4gICAgICAgICAgICBuZXdFcnJvcltwcm9wXSA9IGVycltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXNzYWdlIGlzbid0IHBhcnQgb2YgdGhlIGVudW1lcmFibGUgc2V0XG4gICAgICAgIGlmIChlcnIubWVzc2FnZSkge1xuICAgICAgICAgICAgbmV3RXJyb3IubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdFcnJvcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcihlcnIpO1xufVxuZXhwb3J0cy5mb3JtYXRFcnJvciA9IGZvcm1hdEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LWVycm9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sqlite/build/utils/format-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sqlite/build/utils/migrate.js":
/*!****************************************************!*\
  !*** ./node_modules/sqlite/build/utils/migrate.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.migrate = exports.readMigrations = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nasync function readMigrations(migrationPath) {\n    const migrationsPath = migrationPath || path.join(process.cwd(), 'migrations');\n    const location = path.resolve(migrationsPath);\n    // Get the list of migration files, for example:\n    //   { id: 1, name: 'initial', filename: '001-initial.sql' }\n    //   { id: 2, name: 'feature', filename: '002-feature.sql' }\n    const migrationFiles = await new Promise((resolve, reject) => {\n        fs.readdir(location, (err, files) => {\n            if (err) {\n                return reject(err);\n            }\n            resolve(files\n                .map(x => x.match(/^(\\d+).(.*?)\\.sql$/))\n                .filter(x => x !== null)\n                .map(x => ({ id: Number(x[1]), name: x[2], filename: x[0] }))\n                .sort((a, b) => Math.sign(a.id - b.id)));\n        });\n    });\n    if (!migrationFiles.length) {\n        throw new Error(`No migration files found in '${location}'.`);\n    }\n    // Get the list of migrations, for example:\n    //   { id: 1, name: 'initial', filename: '001-initial.sql', up: ..., down: ... }\n    //   { id: 2, name: 'feature', filename: '002-feature.sql', up: ..., down: ... }\n    return Promise.all(migrationFiles.map(migration => new Promise((resolve, reject) => {\n        const filename = path.join(location, migration.filename);\n        fs.readFile(filename, 'utf-8', (err, data) => {\n            if (err) {\n                return reject(err);\n            }\n            const [up, down] = data.split(/^--\\s+?down\\b/im);\n            const migrationData = migration;\n            migrationData.up = up.replace(/^-- .*?$/gm, '').trim(); // Remove comments\n            migrationData.down = down ? down.trim() : ''; // and trim whitespaces\n            resolve(migrationData);\n        });\n    })));\n}\nexports.readMigrations = readMigrations;\n/**\n * Migrates database schema to the latest version\n */\nasync function migrate(db, config = {}) {\n    config.force = config.force || false;\n    config.table = config.table || 'migrations';\n    const { force, table } = config;\n    const migrations = config.migrations\n        ? config.migrations\n        : await readMigrations(config.migrationsPath);\n    // Create a database table for migrations meta data if it doesn't exist\n    await db.run(`CREATE TABLE IF NOT EXISTS \"${table}\" (\n  id   INTEGER PRIMARY KEY,\n  name TEXT    NOT NULL,\n  up   TEXT    NOT NULL,\n  down TEXT    NOT NULL\n)`);\n    // Get the list of already applied migrations\n    let dbMigrations = await db.all(`SELECT id, name, up, down FROM \"${table}\" ORDER BY id ASC`);\n    // Undo migrations that exist only in the database but not in files,\n    // also undo the last migration if the `force` option is enabled.\n    const lastMigration = migrations[migrations.length - 1];\n    for (const migration of dbMigrations\n        .slice()\n        .sort((a, b) => Math.sign(b.id - a.id))) {\n        if (!migrations.some(x => x.id === migration.id) ||\n            (force && migration.id === lastMigration.id)) {\n            await db.run('BEGIN');\n            try {\n                await db.exec(migration.down);\n                await db.run(`DELETE FROM \"${table}\" WHERE id = ?`, migration.id);\n                await db.run('COMMIT');\n                dbMigrations = dbMigrations.filter(x => x.id !== migration.id);\n            }\n            catch (err) {\n                await db.run('ROLLBACK');\n                throw err;\n            }\n        }\n        else {\n            break;\n        }\n    }\n    // Apply pending migrations\n    const lastMigrationId = dbMigrations.length\n        ? dbMigrations[dbMigrations.length - 1].id\n        : 0;\n    for (const migration of migrations) {\n        if (migration.id > lastMigrationId) {\n            await db.run('BEGIN');\n            try {\n                await db.exec(migration.up);\n                await db.run(`INSERT INTO \"${table}\" (id, name, up, down) VALUES (?, ?, ?, ?)`, migration.id, migration.name, migration.up, migration.down);\n                await db.run('COMMIT');\n            }\n            catch (err) {\n                await db.run('ROLLBACK');\n                throw err;\n            }\n        }\n    }\n}\nexports.migrate = migrate;\n//# sourceMappingURL=migrate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3FsaXRlL2J1aWxkL3V0aWxzL21pZ3JhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLHNCQUFzQjtBQUN4QyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOENBQThDO0FBQzNFO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsMERBQTBEO0FBQzFEO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxNQUFNO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9ldmFubi9Eb2N1bWVudHMvR2l0SHViL1NTTE9KX0dhbWUvbm9kZV9tb2R1bGVzL3NxbGl0ZS9idWlsZC91dGlscy9taWdyYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5taWdyYXRlID0gZXhwb3J0cy5yZWFkTWlncmF0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuYXN5bmMgZnVuY3Rpb24gcmVhZE1pZ3JhdGlvbnMobWlncmF0aW9uUGF0aCkge1xuICAgIGNvbnN0IG1pZ3JhdGlvbnNQYXRoID0gbWlncmF0aW9uUGF0aCB8fCBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ21pZ3JhdGlvbnMnKTtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHBhdGgucmVzb2x2ZShtaWdyYXRpb25zUGF0aCk7XG4gICAgLy8gR2V0IHRoZSBsaXN0IG9mIG1pZ3JhdGlvbiBmaWxlcywgZm9yIGV4YW1wbGU6XG4gICAgLy8gICB7IGlkOiAxLCBuYW1lOiAnaW5pdGlhbCcsIGZpbGVuYW1lOiAnMDAxLWluaXRpYWwuc3FsJyB9XG4gICAgLy8gICB7IGlkOiAyLCBuYW1lOiAnZmVhdHVyZScsIGZpbGVuYW1lOiAnMDAyLWZlYXR1cmUuc3FsJyB9XG4gICAgY29uc3QgbWlncmF0aW9uRmlsZXMgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZzLnJlYWRkaXIobG9jYXRpb24sIChlcnIsIGZpbGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShmaWxlc1xuICAgICAgICAgICAgICAgIC5tYXAoeCA9PiB4Lm1hdGNoKC9eKFxcZCspLiguKj8pXFwuc3FsJC8pKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoeCA9PiB4ICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIC5tYXAoeCA9PiAoeyBpZDogTnVtYmVyKHhbMV0pLCBuYW1lOiB4WzJdLCBmaWxlbmFtZTogeFswXSB9KSlcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gTWF0aC5zaWduKGEuaWQgLSBiLmlkKSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoIW1pZ3JhdGlvbkZpbGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1pZ3JhdGlvbiBmaWxlcyBmb3VuZCBpbiAnJHtsb2NhdGlvbn0nLmApO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIGxpc3Qgb2YgbWlncmF0aW9ucywgZm9yIGV4YW1wbGU6XG4gICAgLy8gICB7IGlkOiAxLCBuYW1lOiAnaW5pdGlhbCcsIGZpbGVuYW1lOiAnMDAxLWluaXRpYWwuc3FsJywgdXA6IC4uLiwgZG93bjogLi4uIH1cbiAgICAvLyAgIHsgaWQ6IDIsIG5hbWU6ICdmZWF0dXJlJywgZmlsZW5hbWU6ICcwMDItZmVhdHVyZS5zcWwnLCB1cDogLi4uLCBkb3duOiAuLi4gfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChtaWdyYXRpb25GaWxlcy5tYXAobWlncmF0aW9uID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoLmpvaW4obG9jYXRpb24sIG1pZ3JhdGlvbi5maWxlbmFtZSk7XG4gICAgICAgIGZzLnJlYWRGaWxlKGZpbGVuYW1lLCAndXRmLTgnLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW3VwLCBkb3duXSA9IGRhdGEuc3BsaXQoL14tLVxccys/ZG93blxcYi9pbSk7XG4gICAgICAgICAgICBjb25zdCBtaWdyYXRpb25EYXRhID0gbWlncmF0aW9uO1xuICAgICAgICAgICAgbWlncmF0aW9uRGF0YS51cCA9IHVwLnJlcGxhY2UoL14tLSAuKj8kL2dtLCAnJykudHJpbSgpOyAvLyBSZW1vdmUgY29tbWVudHNcbiAgICAgICAgICAgIG1pZ3JhdGlvbkRhdGEuZG93biA9IGRvd24gPyBkb3duLnRyaW0oKSA6ICcnOyAvLyBhbmQgdHJpbSB3aGl0ZXNwYWNlc1xuICAgICAgICAgICAgcmVzb2x2ZShtaWdyYXRpb25EYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfSkpKTtcbn1cbmV4cG9ydHMucmVhZE1pZ3JhdGlvbnMgPSByZWFkTWlncmF0aW9ucztcbi8qKlxuICogTWlncmF0ZXMgZGF0YWJhc2Ugc2NoZW1hIHRvIHRoZSBsYXRlc3QgdmVyc2lvblxuICovXG5hc3luYyBmdW5jdGlvbiBtaWdyYXRlKGRiLCBjb25maWcgPSB7fSkge1xuICAgIGNvbmZpZy5mb3JjZSA9IGNvbmZpZy5mb3JjZSB8fCBmYWxzZTtcbiAgICBjb25maWcudGFibGUgPSBjb25maWcudGFibGUgfHwgJ21pZ3JhdGlvbnMnO1xuICAgIGNvbnN0IHsgZm9yY2UsIHRhYmxlIH0gPSBjb25maWc7XG4gICAgY29uc3QgbWlncmF0aW9ucyA9IGNvbmZpZy5taWdyYXRpb25zXG4gICAgICAgID8gY29uZmlnLm1pZ3JhdGlvbnNcbiAgICAgICAgOiBhd2FpdCByZWFkTWlncmF0aW9ucyhjb25maWcubWlncmF0aW9uc1BhdGgpO1xuICAgIC8vIENyZWF0ZSBhIGRhdGFiYXNlIHRhYmxlIGZvciBtaWdyYXRpb25zIG1ldGEgZGF0YSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgYXdhaXQgZGIucnVuKGBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyBcIiR7dGFibGV9XCIgKFxuICBpZCAgIElOVEVHRVIgUFJJTUFSWSBLRVksXG4gIG5hbWUgVEVYVCAgICBOT1QgTlVMTCxcbiAgdXAgICBURVhUICAgIE5PVCBOVUxMLFxuICBkb3duIFRFWFQgICAgTk9UIE5VTExcbilgKTtcbiAgICAvLyBHZXQgdGhlIGxpc3Qgb2YgYWxyZWFkeSBhcHBsaWVkIG1pZ3JhdGlvbnNcbiAgICBsZXQgZGJNaWdyYXRpb25zID0gYXdhaXQgZGIuYWxsKGBTRUxFQ1QgaWQsIG5hbWUsIHVwLCBkb3duIEZST00gXCIke3RhYmxlfVwiIE9SREVSIEJZIGlkIEFTQ2ApO1xuICAgIC8vIFVuZG8gbWlncmF0aW9ucyB0aGF0IGV4aXN0IG9ubHkgaW4gdGhlIGRhdGFiYXNlIGJ1dCBub3QgaW4gZmlsZXMsXG4gICAgLy8gYWxzbyB1bmRvIHRoZSBsYXN0IG1pZ3JhdGlvbiBpZiB0aGUgYGZvcmNlYCBvcHRpb24gaXMgZW5hYmxlZC5cbiAgICBjb25zdCBsYXN0TWlncmF0aW9uID0gbWlncmF0aW9uc1ttaWdyYXRpb25zLmxlbmd0aCAtIDFdO1xuICAgIGZvciAoY29uc3QgbWlncmF0aW9uIG9mIGRiTWlncmF0aW9uc1xuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gTWF0aC5zaWduKGIuaWQgLSBhLmlkKSkpIHtcbiAgICAgICAgaWYgKCFtaWdyYXRpb25zLnNvbWUoeCA9PiB4LmlkID09PSBtaWdyYXRpb24uaWQpIHx8XG4gICAgICAgICAgICAoZm9yY2UgJiYgbWlncmF0aW9uLmlkID09PSBsYXN0TWlncmF0aW9uLmlkKSkge1xuICAgICAgICAgICAgYXdhaXQgZGIucnVuKCdCRUdJTicpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBkYi5leGVjKG1pZ3JhdGlvbi5kb3duKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBkYi5ydW4oYERFTEVURSBGUk9NIFwiJHt0YWJsZX1cIiBXSEVSRSBpZCA9ID9gLCBtaWdyYXRpb24uaWQpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGRiLnJ1bignQ09NTUlUJyk7XG4gICAgICAgICAgICAgICAgZGJNaWdyYXRpb25zID0gZGJNaWdyYXRpb25zLmZpbHRlcih4ID0+IHguaWQgIT09IG1pZ3JhdGlvbi5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGIucnVuKCdST0xMQkFDSycpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFwcGx5IHBlbmRpbmcgbWlncmF0aW9uc1xuICAgIGNvbnN0IGxhc3RNaWdyYXRpb25JZCA9IGRiTWlncmF0aW9ucy5sZW5ndGhcbiAgICAgICAgPyBkYk1pZ3JhdGlvbnNbZGJNaWdyYXRpb25zLmxlbmd0aCAtIDFdLmlkXG4gICAgICAgIDogMDtcbiAgICBmb3IgKGNvbnN0IG1pZ3JhdGlvbiBvZiBtaWdyYXRpb25zKSB7XG4gICAgICAgIGlmIChtaWdyYXRpb24uaWQgPiBsYXN0TWlncmF0aW9uSWQpIHtcbiAgICAgICAgICAgIGF3YWl0IGRiLnJ1bignQkVHSU4nKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGIuZXhlYyhtaWdyYXRpb24udXApO1xuICAgICAgICAgICAgICAgIGF3YWl0IGRiLnJ1bihgSU5TRVJUIElOVE8gXCIke3RhYmxlfVwiIChpZCwgbmFtZSwgdXAsIGRvd24pIFZBTFVFUyAoPywgPywgPywgPylgLCBtaWdyYXRpb24uaWQsIG1pZ3JhdGlvbi5uYW1lLCBtaWdyYXRpb24udXAsIG1pZ3JhdGlvbi5kb3duKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBkYi5ydW4oJ0NPTU1JVCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGF3YWl0IGRiLnJ1bignUk9MTEJBQ0snKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLm1pZ3JhdGUgPSBtaWdyYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWlncmF0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sqlite/build/utils/migrate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sqlite/build/utils/strings.js":
/*!****************************************************!*\
  !*** ./node_modules/sqlite/build/utils/strings.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toSqlParams = void 0;\n/**\n * Allows for using strings and `sql-template-strings`. Converts both to a\n * format that's usable by the SQL methods\n *\n * @param sql A SQL string or `sql-template-strings` object\n * @param params An array of parameters\n */\nfunction toSqlParams(sql, params = []) {\n    if (typeof sql === 'string') {\n        return {\n            sql,\n            params\n        };\n    }\n    return {\n        sql: sql.sql,\n        params: sql.values\n    };\n}\nexports.toSqlParams = toSqlParams;\n//# sourceMappingURL=strings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc3FsaXRlL2J1aWxkL3V0aWxzL3N0cmluZ3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyIvVXNlcnMvZXZhbm4vRG9jdW1lbnRzL0dpdEh1Yi9TU0xPSl9HYW1lL25vZGVfbW9kdWxlcy9zcWxpdGUvYnVpbGQvdXRpbHMvc3RyaW5ncy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9TcWxQYXJhbXMgPSB2b2lkIDA7XG4vKipcbiAqIEFsbG93cyBmb3IgdXNpbmcgc3RyaW5ncyBhbmQgYHNxbC10ZW1wbGF0ZS1zdHJpbmdzYC4gQ29udmVydHMgYm90aCB0byBhXG4gKiBmb3JtYXQgdGhhdCdzIHVzYWJsZSBieSB0aGUgU1FMIG1ldGhvZHNcbiAqXG4gKiBAcGFyYW0gc3FsIEEgU1FMIHN0cmluZyBvciBgc3FsLXRlbXBsYXRlLXN0cmluZ3NgIG9iamVjdFxuICogQHBhcmFtIHBhcmFtcyBBbiBhcnJheSBvZiBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIHRvU3FsUGFyYW1zKHNxbCwgcGFyYW1zID0gW10pIHtcbiAgICBpZiAodHlwZW9mIHNxbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNxbCxcbiAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzcWw6IHNxbC5zcWwsXG4gICAgICAgIHBhcmFtczogc3FsLnZhbHVlc1xuICAgIH07XG59XG5leHBvcnRzLnRvU3FsUGFyYW1zID0gdG9TcWxQYXJhbXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sqlite/build/utils/strings.js\n");

/***/ })

};
;